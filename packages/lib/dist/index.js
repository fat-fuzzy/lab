!function(o,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(((o="undefined"!=typeof globalThis?globalThis:o||self)["dist/index"]=o["dist/index"]||{},o["dist/index"].cjs=o["dist/index"].cjs||{},o["dist/index"].cjs.js={}))}(this,(function(o){"use strict";function t(o){const t=o.clientWidth,n=o.clientHeight;o.width===t&&o.height===n||(o.width=t,o.height=n)}function n(o){return Math.floor(Math.random()*o)}function e(o,t){return Number(Math.round(o+"e"+t)+"e-"+t)}var i=Object.freeze({__proto__:null,resize:t,resizeHD:function(o){const t=window.devicePixelRatio,n=Math.floor(o.clientWidth*t),e=Math.floor(o.clientHeight*t);o.width===n&&o.height===e||(o.width=n,o.height=e)},randomInt:n,multiply:function(o){return new Array(100).fill(0).map(((t,n)=>({class:"hidden",character:o[n%o.length],x:100*Math.random(),y:-10-100*Math.random(),ratio:.1+1*Math.random()}))).sort(((o,t)=>o.ratio-t.ratio))},degToRad:function(o){return o*(Math.PI/180)},round:e});function r(o,t,n){const e=o.createShader(t);o.shaderSource(e,n),o.compileShader(e);if(o.getShaderParameter(e,o.COMPILE_STATUS))return e;const i=`Could not compile shader \n\n${o.getShaderInfoLog(e)}`;throw o.deleteShader(e),i}function a(o,t,n){const e=o.createProgram();o.attachShader(e,t),o.attachShader(e,n),o.linkProgram(e);if(o.getProgramParameter(e,o.LINK_STATUS))return e;const i=`Could not compile program \n\n${o.getShaderInfoLog(e)}`;throw o.deleteProgram(e),i}var c=Object.freeze({__proto__:null,createShader:r,createProgram:a});function s(o,t){o.bufferData(o.ARRAY_BUFFER,new Float32Array(t),o.STATIC_DRAW)}function l(o,t,n,e,i){const r=t+e,a=n+i;s(o,[t,n,r,n,t,a,t,a,r,n,r,a])}function f(o,t){l(o,n(300),n(300),n(300),n(300)),o.uniform4f(t,Math.random(),Math.random(),Math.random(),1),o.drawArrays(o.TRIANGLES,0,6)}function u(o,t,n){const e=o.getContext("webgl");e||alert("Sorry buddy, can't find WebGL in your browser ");const i=t,c=n,s=a(e,r(e,e.VERTEX_SHADER,i),r(e,e.FRAGMENT_SHADER,c));e.useProgram(s);const l=e.getAttribLocation(s,"a_position"),f=e.getUniformLocation(s,"u_color"),u=e.getUniformLocation(s,"u_translation"),d=e.getUniformLocation(s,"u_resolution"),h=e.getUniformLocation(s,"u_rotation"),m=e.getUniformLocation(s,"u_scale"),p=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,p),{gl:e,resolutionUniformLocation:d,colorUniformLocation:f,translationUniformLocation:u,positionAttributeLocation:l,rotationUniformLocation:h,scaleUniformLocation:m,positionBuffer:p}}function d(o){const{gl:n,resolutionUniformLocation:e,positionAttributeLocation:i,positionBuffer:r}=o;t(n.canvas),n.viewport(0,0,n.canvas.width,n.canvas.height),n.uniform2f(e,n.canvas.width,n.canvas.height),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.enableVertexAttribArray(i),n.bindBuffer(n.ARRAY_BUFFER,r);const a=n.FLOAT;n.vertexAttribPointer(i,2,a,!1,0,0)}function h(o){const{webGlProps:n,translation:e,rotation:i,scale:r,color:a}=o,{gl:c,resolutionUniformLocation:s,colorUniformLocation:l,translationUniformLocation:f,positionAttributeLocation:u,rotationUniformLocation:d,scaleUniformLocation:h,positionBuffer:m}=n;t(c.canvas),c.viewport(0,0,c.canvas.width,c.canvas.height),c.clearColor(0,0,0,0),c.clear(c.COLOR_BUFFER_BIT),c.enableVertexAttribArray(u),c.bindBuffer(c.ARRAY_BUFFER,m);const p=c.FLOAT;let v=0;c.vertexAttribPointer(u,2,p,!1,0,v),c.uniform2f(s,c.canvas.width,c.canvas.height),c.uniform4fv(l,a),c.uniform2fv(f,e),c.uniform2fv(d,i),c.uniform2fv(h,r);const g=c.TRIANGLES;v=0;c.drawArrays(g,v,18)}function m(o){const{gl:t,colorUniformLocation:n}=o;d(o),function(o,t,n){for(let e=0;e<n;++e)f(o,t)}(t,n,1)}function p(o){const{webGlProps:t,color:n}=o,{gl:e,colorUniformLocation:i}=t;!function(o,t,n){o.uniform4fv(t,n),s(o,[0,0,30,0,0,150,0,150,30,0,30,150,30,0,100,0,30,30,30,30,100,0,100,30,30,60,67,60,30,90,30,90,67,60,67,90]);const e=o.TRIANGLES;o.drawArrays(e,0,18)}(e,i,n),h(o)}var v=Object.freeze({__proto__:null,initScene:u,drawScene:d,drawSceneT2DGL:h,rectanglesScene:m,translationSceneViaDOM:function(o,t,n,e,i){const{gl:r,colorUniformLocation:a}=o;d(o),function(o,t,n,e,i,r){o.uniform4fv(t,e),l(o,n[0],n[1],i,r);const a=o.TRIANGLES;o.drawArrays(a,0,6)}(r,a,t,n,e,i)},translationSceneViaWebGL:p,render:function(){}});const g="\n// fragment shaders don't have a default precision so we need\n// to pick one. mediump is a good default\nprecision mediump float;\nuniform vec4 u_color;\n\nvoid main() {\n  // gl_FragColor is a special variable a fragment shader\n  // is responsible for setting\n  // gl_FragColor = vec4(1, 0, 0.5, 1); // return reddish-purple\n  gl_FragColor = u_color;\n}\n",_="\n// an attribute will receive data from a buffer\n// attribute vec4 a_position; vec4 not necessary for 2D\nattribute vec2 a_position;\nuniform vec2 u_resolution;\n\n// all shaders have a main function\nvoid main() {\n  // convert the position from pixels to 0.0 to 1.0\n  vec2 zeroToOne = a_position / u_resolution;\n\n  // convert from 0->1 to 0->2\n  vec2 zeroToTwo = zeroToOne * 2.0;\n\n  // convert from 0->2 to -1->+1 (clip space)\n  vec2 clipSpace = zeroToTwo - 1.0;\n\n  // gl_Position is a special variable in a vertex shader\n  // it is responsible for setting\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1); // 0,0 = top, left (traditional 3D)\n  // gl_Position = vec4(clipSpace, 0, 1); // 0,0 = bottom, left\n}\n",b=[{id:"random-rect",name:"Random",emoji:"🎰",duration:2e3,vert:_,frag:g,init(o){this.webGlProps=u(o,this.vert,this.frag)},run(o){this.webGlProps||this.init(o),m(this.webGlProps)},clear(){this.webGlProps=null}},{id:"random-rect-audio",name:"Audio",emoji:"🥁",audio:!0,duration:4179,playbackRate:2,vert:_,frag:g,init(o){this.webGlProps=u(o,this.vert,this.frag)},run(o){this.webGlProps||this.init(o),m(this.webGlProps)},clear(){this.webGlProps=null}},{id:"2D",name:"2D",emoji:"📐",interactive:!0,webGlProps:null,vert:"\n// an attribute will receive data from a buffer\n// attribute vec4 a_position; vec4 not necessary for 2D\nattribute vec2 a_position;\nuniform vec2 u_resolution;\nuniform vec2 u_translation;\nuniform vec2 u_rotation;\nuniform vec2 u_scale;\n\n// all shaders have a main function\nvoid main() {\n  // Scale the position\n  vec2 scaledPosition = a_position * u_scale;\n  \n  // Rotate the position\n  vec2 rotatedPosition = vec2(\n    scaledPosition.x * u_rotation.y + scaledPosition.y * u_rotation.x,\n    scaledPosition.y * u_rotation.y - scaledPosition.x * u_rotation.x\n  );\n\n  // Add in the translation\n  vec2 position = rotatedPosition + u_translation;\n\n  // convert the position from pixels to 0.0 to 1.0\n  vec2 zeroToOne = position / u_resolution;\n\n  // convert from 0->1 to 0->2\n  vec2 zeroToTwo = zeroToOne * 2.0;\n\n  // convert from 0->2 to -1->+1 (clip space)\n  vec2 clipSpace = zeroToTwo - 1.0;\n\n  // gl_Position is a special variable in a vertex shader\n  // it is responsible for setting\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1); // 0,0 = top, left (traditional 3D)\n  // gl_Position = vec4(clipSpace, 0, 1); // 0,0 = bottom, left\n}\n",frag:g,color:null,init(o){this.webGlProps=u(o,this.vert,this.frag)},run(o,t){this.webGlProps||this.init(o);const{color:n,translation:e,rotation:i,scale:r}=t;this.color=n;p({webGlProps:this.webGlProps,translation:e,rotation:i,scale:r,color:n})},update(o){const{translation:t,rotation:n,scale:e}=o;h({webGlProps:this.webGlProps,translation:t,rotation:n,scale:e,color:this.color})},clear(){this.webGlProps=null}},{id:"poop",name:"A Feature",emoji:"💩",type:"test",run(){throw Error("Not a Bug 💩")},clear(){}}];var w=Object.freeze({__proto__:null,animations:b,getGeometryDefaults:function(o,t){return{color:[Math.random(),Math.random(),Math.random(),1],translation:[o/2,t/2],rotation:[0,0],scale:[1,1],width:e(.3*o/5,2),height:e(t/5,2)}}});o.animations=w,o.draw=v,o.utils=i,o.utilsWebGl=c,Object.defineProperty(o,"__esModule",{value:!0})}));
